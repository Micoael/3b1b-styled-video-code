《套娃的数据结构——树链剖分》
（开场白）
观众朋友们，大家好。欢迎收看我的视频。
本期视频将简单了解树链剖分。
首先，我们花一些时间了解什么是DFS序
然后，我们介绍树链剖分的一种方法——重链剖分。
最后，我们来求解LCA问题。

（DFS序）
现在我们来看DFS序。
把一棵树DFS，并且按照时间顺序进行标注。
（边上的数字是边上的顺序，不是边权）
可以发现，一颗子树的编号总是连续的。
比如这边的6,7,8,9.

（重链剖分）
接下来，对这棵树进行重链剖分。
考虑这样一棵树
我们可以把这棵树按照子树的大小划分成重儿子和轻儿子。
一个树子节点越多，那么他的重(质)量就越大。
考虑1连向的的三个节点。
他们的size分别为2,4,3.
因为4>3>2，把4设置为重儿子。
如果几个儿子一样大的话，那就随意选一个就好了。
重儿子用黄色标注。
接着，把点的编号抹掉，重新执行dfs。遇到重儿子就先走重儿子。
用重边把重儿子连接起来。可以形成黄色的重链。
每条重链维护一个top，表示重链的顶端
要完成这样的操作，我们需要维护这些参数。
dep(x) = x节点深度
fa(x) = x节点父亲
son(x) = x节点的重儿子
size(x) = x节点的大小
num(x) = x节点输入的原始值
id(x) = x的第二次编号
val(x) = x在新编号下对应的原节点
top(x) = x节点所在链的顶端


（LCA）
那么这样做又和LCA有什么关联呢？
考虑这样一条链，如果求解LCA(1,4)
答案显然是4.
那如果不在一条链呢
可以借助重链的top属性来加速地“跳跃”
比如求解LCA(7,9)
转换到同一条链上时，
判断两点同链的依据是top[a]==top[b]
要相转换到同一条链上，
我们要问两个问题：
应该让哪个点先跳到哪呢？

比如我们先让这个点往上跳。
发现二者永远无法共链。
发现top[9]的深度>top[7]的深度
可见，只有让顶端深度深的节点先跳，才可以找到LCA.
并且，我们可以一步让深度深的点跳到它的father节点，并再一次判断是否共链。不过不共链，那么再跳。
这种情况下，已经共链了。所以输出深度较深的点。
这样，我们就可以求解出LCA了。
大佬们可能要发问了：那你重新走了一遍DFS有何用呢？
解决这个问题前，先来做一个注释

（树上修改）

DFS第二遍的真相是维护数据结构。
我们把原来的树进行了重链剖分，其最终目的的为了其他的数据结构。
因为我们的重链有如下两条性质，加速了我们的查找过程。
使用其他数据结构（如线段树）维护，需要区间的连续性。
我们试着用线段树来维护整个区间。

这样我们就可以方便的对区间进行加，查询操作。
比如从x到y的简单路径中，每个节点的值同时加m
如果二者不在同一条链的话，对它到它这个链的顶端这样一个区间增加m。
然后跳到这个链的顶端的父亲节点。因为这个链的顶端已经被修改过了。
接着判断是否属于同一条链。如果不是重复，如果是的话
就直接对当前跳到的这个点和另一个点这一个区间增加m。

特别像LCA，对吧。

查询和的话和刚刚这一过程类似。

还有一种问法是把它所有子树加一个值或者统计。
这种情况，我们还是可以运用dfs序 的一个性质——子树dfs序节点连续。
那怎么确定在哪停止呢？
有size数组。
二者一结合，可以清晰地发现。我们需要对x,x+size[x]-1这个区间进行加操作。
这种情况也适用于查询。

（代码实现）
当然，说了那么一大堆东西，如何实现代码？
这里，我们使用洛谷P3178这道题做示例。
让我简单准备一下....

现在，我们来实现这些步骤。
首先，使用链式前向星存储这一坨东西。
cnt = 第二次dfs当前映射的编号
dep(x) = x节点深度
fa(x) = x节点父亲
son(x) = x节点的重儿子
size(x) = x节点的大小
num(x) = x节点输入的原始值
id(x) = x的第二次编号
val(x) = x在新编号下对应的原节点
top(x) = x节点所在链的顶端

首先进行第一次dfs.
先记录一下深度。
大小的统计方法是把每颗子树大小相加。
叶子结点的大小为1.
如果这个子树的节点比其他的都要大，那么设置它为重孩子。

再来看第二次dfs。
传入元节点编号u和链的顶端tp
首先给节点u一个新编号cnt++
然后记录这个节点的原始编号u到这个节点。
最后，把这个节点的顶端赋予tp。
首先搜查重儿子，并且进行下一层递归调用，并且其顶端不变。
然后搜查轻儿子，并且把它的top赋予自己。表明这是新的一条链。

下面来看套娃的数据结构——线段树。
关于线段树，我不打算涉及太多。简单来说，线段树可以快速进行区间修改，
求和，查询操作。

建树是build（左端点，右端点）。
我们针对num[val[l]]（第二次dfs的节点编号的值）建树。
修改是modify（左端点，右端点，区间左端，区间右端，加的数值）
查询时query（左端点，右端点，区间左端，区间右端）

下面来看ask操作。
针对ask操作就可以运用刚刚说的树上相关修改操作了。
首先判断是否在同一条链上。
如果二者不在同一条链的话，查询它到它这个链的顶端这样一个区间
然后跳到这个链的顶端的父亲节点。
在判断是否属于同一条链。如果不是，重复，如果是的话
就直接查询当前跳到的这个点和另一个点这一个区间。
二者一求和，即可。

再坚持一下，终于到了main函数了~
先读入相关数据，加边，进行两次dfs.
这之后，就可以直接建树了。
然后按照他要求的操作即可。

（结束）
这就是我们今天的全部内容了。在结束之前，我想说说这么一个方法的来源。

这个方法来自Tarjan和Sleator在1983年发表的A Data Structure for Dynamic Tree这篇论文
（JOURNAL OF COMPUTER AND SYSTEM SCIENCES 26, 362-391 (1983) ）

——可以理解为Link Cut Tree,它可以对一个树进行动态加边等操作。

我们回来再说。

说到Tarjan,大家都可以想到《算法导论》每章末尾的本章注记的板块，几乎都有他的身影。
向Tarjan致敬。