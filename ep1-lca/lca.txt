G:\BILIBILI\7-17\ARCTIME_PRO_2.2.1_WIN64\ARCTIME_PRO_2.2.1_WIN64
1
各位观众朋友们，大家好。
本视频将要以动画的方式让您完全理解最近公共祖先问题。
LCA，即最近公共祖先。
我们来看如下的一棵树：
节点3和节点4的最近公共祖先是节点1.
我们今天主要讲解用倍增的方法介绍如何高效实现这个操作。

2
在介绍倍增解法之前，我们先用暴力试着求解一下。
毕竟，暴力有时也可以帮助我们得到一些思路。
比如有一棵树，每个节点具有编号和深度两个属性。
这两个属性我们可以在dfs中求出。

比如我们求lca(3,9)
注意到深度不同。
我们可以想到，既然深度不同，我们先让它转到同一深度
然后一起向上跳，直到相遇。
那么1就是他们的lca.
不过有一点小特例。比如我要求1和10的lca。
注意到深度还是不同。
转换到同一深度的时候，两个点已经重合，不需要往上跳了。

一层一层跳太慢了。有没有什么办法加速这个过程呢？
这就需要倍增了。

3
抛开树状结构，我们了解倍增。
假设你站在0的位置，准备去7个格子之外的地方。
你可以一步一步的向右移动
这样太慢了。有没有什么快速的方法呢？
注意到，对于每一个格子来说，
我们可以记录从这个格子向前进2^0,2^1,2^2...个格子到达的地点。
也就是这个格子之后1,2,4,8...个格子到达的地方。

比如f[1][0]表示从1出发，向右跨2^0步，到达的是2.
那么f[1][1]表示从1出发，向右跨2^1步，到达的是3.
f[2][0]表示从2出发，向右跨2^0步，到达的是3.
f[i][j]表示从i出发，向右跨2^j步，到达的是w.

我们又发现，向右移动2^2个格子可以拆分成
先移动2^1个格子，然后再移动2^1个格子。

由此不难看出，从i出发，向右跨2^j步，到达的位置，
就等于先向右跨2^(j-1)步
所到达的格子
再向右跨2^(j-1)步。
我们可以通过递推式预处理出一个表格。

现在我们在0号位置上，然后从最大的那个开始试探。
因为8>7，我们不能跳8格。
继续往上寻找，4<7,向右跳4格。

现在我们在4号位置上，重复刚刚的操作。
因为12>7,8>7,我们不能跳到12格或者8格。
继续往上寻找，6<7,向右跳到6。

现在我们在6号位置上，重复刚刚的操作。（-1表示节点不存在）
因为-1不存在,10>7,8>7,我们不能向右跳2^2或2^1格。
继续往上寻找，7=7向右跳到7。循环结束。

这样，我们就比朴素方法快了很多。

#3
刚刚我们解决LCA的步骤有二：
先跳到同样的深度
在跳到它们相遇为止。
我们试着用倍增优化这个过程。
还是这棵树
我们把上面的定义改一下
即：f[i][j]表示i顶点，第2^j个父亲，是w.
我们同样可以预处理出一张表格。
限于屏幕空间原因，不再列出。

比如求解lca(1,14)
由于他们的深度差是3，我们尽可能选取尽可能大的向上跳的高度。
没有第2^{10}个父亲
没有第2^{9}个父亲
2^{2}个父亲的深度跳的太多了
2^{1}个父亲正好。

看到他们不是同一个节点。开始下一步：一起向上跳。
这个可以用倍增优化吗？

我们来看一个例子lca(7,8)
还是尽可能向上跳
可以发现2^{1}个父亲是可以的。
于是他们就跳到了1.
可是这个答案不正确，虽然他们是公共的祖先，但是这不是最近的。

我们发现思路错了。刚刚可以尽可能向上跳是因为我们知道了一共要跳多少格。
这次是未知的
所以，我们应该让它尽可能向上跳，但是限制条件是它们不相遇。

向上跳2^1个父亲，重合，不跳。
向上跳2^0个父亲，重合，不跳。
发现没法跳了。
那么7的父亲就是他们的LCA,就是3.


#4
下面上代码

我们使用链式前向星来存图。(如果你不知道这是什么，请参阅我的另一个视频。)
首先打上链式前向星的板子（比如这里我加双向边做无向边）
（注：）一般来说，前向星枚举出边如右上代码片段所示
前向星访问点的属性如右下代码片段所示

接下来通过dfs获得每个节点的深度信息，并且顺便填写刚刚的表格。

v表示层数，father是父节点。
dfs开始，我们首先让它儿子的节点深度+1.
接着运用表达式递推。
接着调用下一层递归。此时，把f[p1][0]设为父亲。
（因为用双向边模拟无向边，所以判断是否回去了）

处理完表格之后，开始LCA求解。
为了说明方便，屏幕右下角有一棵树来展示这个过程。

lca(x,y)表示x和y的LCA
如果x的深度>y的深度，让他们交换。
(分类讨论x和y的深度显然太麻烦了)

然后从他的2^20次方开始尝试，看看可不可以跳
顺便判断是不是同一个点。

接着继续尽可能向上跳，但是二者不能相遇。
例图可以向上跳1，不相遇。
这时发现无法继续向上跳。
那么他们的LCA就是节点1(或2)的祖先。

main函数使用的时候，只需要得到数的根填进去即可。























